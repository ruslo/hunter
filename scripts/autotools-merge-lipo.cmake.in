# Copyright (c) 2015 Ruslan Baratov, Alexandre Pretyman
# All rights reserved.

### Input params check

string(COMPARE EQUAL "@multi_arch_install_root@" "" is_empty)
if(is_empty)
  message(FATAL_ERROR "multi_arch_install_root is empty")
endif()

string(COMPARE EQUAL "@ios_architectures@" "" is_empty)
if(is_empty)
  message(FATAL_ERROR "ios_architectures is empty")
endif()

string(COMPARE EQUAL "@HUNTER_PACKAGE_INSTALL_PREFIX@" "" is_empty)
if(is_empty)
  message(FATAL_ERROR "HUNTER_PACKAGE_INSTALL_PREFIX is empty")
endif()

set(ios_architectures @ios_architectures@)
set(built_arch_roots)
foreach(x ${ios_architectures})
  list(APPEND built_arch_roots @multi_arch_install_root@/${x})
endforeach()
list(LENGTH ios_architectures total_arch_number)


# We work with the first root path: we move everything, except the *.a static
# library files into @HUNTER_PACKAGE_INSTALL_PREFIX@, then we lipo the static
# libraries together into @HUNTER_PACKAGE_INSTALL_PREFIX@
list(GET built_arch_roots 0 first_built_root)
file(GLOB_RECURSE
    library_files
    RELATIVE
      "${first_built_root}"
    ${first_built_root}/*.a
)
file(GLOB_RECURSE
    all_except_library_files
    RELATIVE
      "${first_built_root}"
    ${first_built_root}/*
)
# Remove the library files
foreach(x ${library_files})
  list(REMOVE_ITEM all_except_library_files ${x})
endforeach()

# Search and replace all occurences of each ${built_arch_root}
# into @HUNTER_PACKAGE_INSTALL_PREFIX@
foreach(built_arch_root ${built_arch_roots})
  foreach(x ${all_except_library_files})
    set(filename ${built_arch_root}/${x})
    file(READ ${filename} file_contents)
    string(REPLACE
        "${built_arch_root}"
        "@HUNTER_PACKAGE_INSTALL_PREFIX@"
        file_contents_after_replace
        "${file_contents}"
    )
    if(NOT "${file_contents}" STREQUAL "${file_contents_after_replace}")
      file(WRITE ${filename} "${file_contents_after_replace}")
    endif()
  endforeach()
endforeach()

# The preprocessor macros below are from
# http://sourceforge.net/p/predef/wiki/Architectures/
# except armv7, which was wrong in the site and was taken from:
# clang -arch armv7 -dD -E config.h
function(preprocessor_macro arch result)
  if(${arch} STREQUAL "armv7")
    set(${result} "__ARM_ARCH_7A__" PARENT_SCOPE)
  elseif(${arch} STREQUAL "armv7s")
    set(${result} "__ARM_ARCH_7S__" PARENT_SCOPE)
  elseif(${arch} STREQUAL "arm64")
    set(${result} "__aarch64__" PARENT_SCOPE)
  elseif(${arch} STREQUAL "i386")
    set(${result} "__i386__" PARENT_SCOPE)
  elseif(${arch} STREQUAL "x86_64")
    set(${result} "__x86_64__" PARENT_SCOPE)
  else()
    message(FATAL_ERROR "Architecture: ${arch} is not supported")
  endif()
endfunction()

# Compare for differences between files in built_arch_roots
# If files are different and are in the include/ directory
# they are merged with #ifdef guards
# If files are different and are not in the include directory
# they are moved into the final install dir with their architecture
# appended to their name with a dash, for example:
#   bin/sqlite3
# becomes
#   bin/sqlite3-armv7
#   bin/sqlite3-armv7s
#   bin/sqlite3-arm64
#   bin/sqlite3-i386
#   bin/sqlite3-x86_64
set(built_arch_roots_except_first ${built_arch_roots})
list(REMOVE_AT built_arch_roots_except_first 0)
foreach(file_name ${all_except_library_files})
  get_filename_component(final_dir
      @HUNTER_PACKAGE_INSTALL_PREFIX@/${file_name}
      DIRECTORY
  )
  file(MAKE_DIRECTORY ${final_dir})
  # make different_roots a list, so it can be printed for better investigation
  set(different_roots)
  foreach(built_arch_root ${built_arch_roots_except_first})
    file(DIFFERENT
        is_different
        FILES
          "${first_built_root}/${file_name}"
          "${built_arch_root}/${file_name}"
    )
    if(is_different)
      list(APPEND different_roots "${built_arch_root}/${file_name}")
    endif()
  endforeach()
  list(LENGTH different_roots len)
  if(${len} EQUAL 0)
    # Files are the same, so we move them to @HUNTER_PACKAGE_INSTALL_PREFIX@
    file(RENAME
        ${first_built_root}/${file_name}
        @HUNTER_PACKAGE_INSTALL_PREFIX@/${file_name}
    )

    # Remove the uneeded copies
    foreach(built_arch_root ${built_arch_roots_except_first})
      file(REMOVE ${built_arch_root}/${file_name})
    endforeach()
  else()
    # Files are not the same
    string(FIND ${file_name} "include/" find_result)
    # If is a file in the include diretory
    if (${find_result} EQUAL 0)
      # then we merge the file contents with #ifdef guards
      set(merged_file_contents)
      set(arch_counter 1)
      foreach(arch ${ios_architectures})
        set(full_path_file_name
            @multi_arch_install_root@/${arch}/${file_name}
        )
        preprocessor_macro(${arch} arch_define)
        if (arch_counter EQUAL 1)
          set(merged_file_contents
"#ifdef ${arch_define}\n"
          )
        else()
          set(merged_file_contents
              "${merged_file_contents}
#elif ${arch_define}\n"
          )
        endif()
          file(READ
              ${full_path_file_name}
              file_contents
          )
          # Append contents to the merged file
          set(merged_file_contents
              "${merged_file_contents}${file_contents}"
          )
          # Discard the file
          file(REMOVE
              ${full_path_file_name}
          )
        if (${arch_counter} EQUAL ${total_arch_number})
          set(merged_file_contents
            "${merged_file_contents}
#else
# error Architecture not supported
#endif\n"
          )
        endif()
        math(EXPR arch_counter ${arch_counter}+1)
      endforeach()
      file(WRITE
          @HUNTER_PACKAGE_INSTALL_PREFIX@/${file_name}
          "${merged_file_contents}"
      )
    else()
      # file is not in the include directory
      foreach(arch ${ios_architectures})
        set(full_path_file_name
            @multi_arch_install_root@/${arch}/${file_name}
        )
        file(RENAME
            ${full_path_file_name}
            "@HUNTER_PACKAGE_INSTALL_PREFIX@/${file_name}-${arch}"
        )
      endforeach()
    endif()
  endif()
endforeach()

# we lipo the libraries into @HUNTER_PACKAGE_INSTALL_PREFIX@
foreach(x ${library_files})
  # if the dir to put the library in, does not exist, then create it
  # this is needed or else lipo could fail
  get_filename_component(dir @HUNTER_PACKAGE_INSTALL_PREFIX@/${x} DIRECTORY)
  file(MAKE_DIRECTORY ${dir})

  set(input_libraries)
  foreach(built_arch_root ${built_arch_roots})
    list(APPEND input_libraries ${built_arch_root}/${x})
  endforeach()

  execute_process(
      COMMAND
        lipo
        -create
        ${input_libraries}
        -o
        @HUNTER_PACKAGE_INSTALL_PREFIX@/${x}
      RESULT_VARIABLE
        lipo_result
      ERROR_VARIABLE
        lipo_error
  )
  if(NOT ${lipo_result} EQUAL 0)
    message(FATAL_ERROR "lipo execution failed: ${lipo_error}")
  endif()

  file(REMOVE ${input_libraries})
endforeach()


# Function to delete empty directories
function(remove_empty_dirs_recursive dir)
  file(GLOB dir_contents ${dir}/*)
  foreach(maybe_dir ${dir_contents})
    if(IS_DIRECTORY ${maybe_dir})
      remove_empty_dirs_recursive(${maybe_dir})
    endif()
  endforeach()

  file(GLOB dir_contents ${dir}/*)
  list(LENGTH dir_contents len)
  if(${len} EQUAL 0)
    # REMOVE_RECURSE is needed because REMOVE won't delete the directory
    file(REMOVE_RECURSE ${dir})
  endif()
endfunction()

# Remove all empty directories from @multi_arch_install_root@
remove_empty_dirs_recursive("@multi_arch_install_root@")
